{
  "name": "postgresql Juju charm",
  "juju_charm_name": "postgresql",
  "revision": "cs:precise/postgresql-98",
  "latest": true,
  "uris": [
    "https://jujucharms.com/postgresql",
    "https://jujucharms.com/postgresql/precise",
    "https://jujucharms.com/postgresql/precise/98",
    "https://api.jujucharms.com/v5/postgresql",
    "https://api.jujucharms.com/v5/precise/postgresql",
    "https://api.jujucharms.com/v5/precise/postgresql-98"
  ],
  "labels": [
    "Juju charm",
    "databases",
    "Type/Middleware/Runtime/Java",
    "Type/Middleware/Runtime/Python",
    "Type/Middleware/Runtime/Ruby",
    "Mode/Guide/Video",
    "Mode/Executable/Bundle/Juju Charm",
    "Type/Devopsware/Build/Java/Ant",
    "Type/Devopsware/Deployment/Juju",
    "Type/Infrastructure/Operating System",
    "Type/Middleware/Runtime/Perl",
    "Type/Middleware/Data Store/Relational/PostgreSQL",
    "Type/Middleware/Data Store/Document-oriented/MongoDB"
  ],
  "info_url": "https://jujucharms.com/postgresql",
  "package_url": "https://api.jujucharms.com/v5/precise/postgresql-98/archive",
  "created": "2015-11-12T12:01:33.807Z",
  "updated": "2015-11-12T12:01:33.807Z",
  "description": "PostgreSQL object-relational SQL database (supported version)\n\nPostgreSQL is a powerful, open source object-relational database system.\nIt has more than 15 years of active development and a proven\narchitecture that has earned it a strong reputation for reliability,\ndata integrity, and correctness. It is fully ACID compliant, has full\nsupport for foreign keys, joins, views, triggers, and stored procedures\n(in multiple languages). It includes most SQL:2008 data types, including\nINTEGER, NUMERIC, BOOLEAN, CHAR, VARCHAR, DATE, INTERVAL, and TIMESTAMP.\nIt also supports storage of binary large objects, including pictures,\nsounds, or video. It has native programming interfaces for C/C++, Java,\n.Net, Perl, Python, Ruby, Tcl, ODBC, among others, and exceptional\ndocumentation (http://www.postgresql.org/docs/manuals/).\n",
  "maintainer": {
    "name": "charmers"
  },
  "juju_charm_subordinate": false,
  "juju_charm_series": "precise",
  "juju_charm_owner": "charmers",
  "requires": [
    {
      "kind": "host",
      "label": "Infrastructure/Operating System/Linux/Ubuntu",
      "version": "= precise"
    },
    {
      "kind": "peer",
      "uri": "https://jujucharms.com/requires/directory-path",
      "self_resolve": true,
      "juju_interface": "directory-path",
      "juju_name": "persistent-storage",
      "juju_role": "requirer",
      "juju_limit": 1
    },
    {
      "kind": "peer",
      "uri": "https://jujucharms.com/requires/syslog",
      "self_resolve": true,
      "juju_interface": "syslog",
      "juju_name": "syslog",
      "juju_role": "requirer",
      "juju_limit": 1
    }
  ],
  "parameters": {
    "admin_addresses": {
      "type": "string",
      "description": "A comma-separated list of IP Addresses (or single IP) admin tools like  pgAdmin3 will connect from, this is most useful for developers running  juju in local mode who need to connect tools like pgAdmin to a postgres.  The IP addresses added here will be included in the pg_hba.conf file  allowing ip connections to all databases on the server from the given  using md5 password encryption.\n",
      "default": "",
      "mapping": "charm_option"
    },
    "advisory_lock_restart_key": {
      "type": "int",
      "description": "An advisory lock key used internally by the charm. You do not need to change it unless it happens to conflict with an advisory lock key being used by your applications.\n",
      "default": 765,
      "mapping": "charm_option"
    },
    "archive_command": {
      "type": "string",
      "description": "Command used to archive WAL files when archive_mode is set and wal_level > minimal.\n",
      "default": "",
      "mapping": "charm_option"
    },
    "archive_mode": {
      "type": "boolean",
      "description": "Enable archiving of WAL files using the command specified by archive_command. If archive_mode is enabled and archive_command not set, then archiving is deferred until archive_command is set and the WAL files will accumulate.\n",
      "default": false,
      "mapping": "charm_option"
    },
    "autovacuum": {
      "type": "boolean",
      "description": "Autovacuum should almost always be running. If you want to turn this off, you are probably following out of date documentation.\n",
      "default": true,
      "mapping": "charm_option"
    },
    "autovacuum_analyze_scale_factor": {
      "type": "float",
      "description": "Fraction of table size before analyze",
      "default": 0.1,
      "mapping": "charm_option"
    },
    "autovacuum_analyze_threshold": {
      "type": "int",
      "description": "min number of row updates before analyze",
      "default": 50,
      "mapping": "charm_option"
    },
    "autovacuum_vacuum_cost_delay": {
      "type": "string",
      "description": "Default vacuum cost delay for autovacuum, in milliseconds; -1 means use vacuum_cost_delay\n",
      "default": "20ms",
      "mapping": "charm_option"
    },
    "autovacuum_vacuum_scale_factor": {
      "type": "float",
      "description": "Fraction of table size before vacuum",
      "default": 0.2,
      "mapping": "charm_option"
    },
    "aws_access_key_id": {
      "type": "string",
      "description": "EXPERIMENTAL. Amazon AWS access key id.",
      "default": null,
      "mapping": "charm_option"
    },
    "aws_secret_access_key": {
      "type": "string",
      "description": "EXPERIMENTAL. Amazon AWS secret access key.",
      "default": null,
      "mapping": "charm_option"
    },
    "backup_dir": {
      "type": "string",
      "description": "Directory to place backups in",
      "default": "/var/lib/postgresql/backups",
      "mapping": "charm_option"
    },
    "backup_retention_count": {
      "type": "int",
      "description": "Number of recent backups to retain.",
      "default": 7,
      "mapping": "charm_option"
    },
    "backup_schedule": {
      "type": "string",
      "description": "Cron-formatted schedule for database backups.",
      "default": "13 4 * * *",
      "mapping": "charm_option"
    },
    "checkpoint_completion_target": {
      "type": "float",
      "description": "checkpoint target duration time, as a fraction of checkpoint_timeout. Range [0.0, 1.0].\n",
      "default": 0.9,
      "mapping": "charm_option"
    },
    "checkpoint_segments": {
      "type": "int",
      "description": "in logfile segments, min 1, 16MB each. Ignored unless 'performance_tuning' is set to 'manual'.\n",
      "default": 10,
      "mapping": "charm_option"
    },
    "checkpoint_timeout": {
      "type": "string",
      "description": "Maximum time between automatic WAL checkpoints. range '30s-1h'. If left empty, the default postgresql value will be used.\n",
      "default": "",
      "mapping": "charm_option"
    },
    "cluster_name": {
      "type": "string",
      "description": "Name of the cluster we want to install the DBs into",
      "default": "main",
      "mapping": "charm_option"
    },
    "collapse_limit": {
      "type": "int",
      "description": "Sets the from_collapse_limit and join_collapse_limit query planner options, controlling the maximum number of tables that can be joined before the turns off the table collapse query optimization.\n",
      "default": -1,
      "mapping": "charm_option"
    },
    "default_statistics_target": {
      "type": "int",
      "description": "Sets the default statistics target for table columns without a column-specific target set via ALTER TABLE SET STATISTICS. Leave unchanged to use the server default, which in recent releases is 100. Ignored unless 'performance_tuning' is 'manual'. Larger values increase the time needed to do ANALYZE, but might improve the quality of the planner's estimates.\n",
      "default": -1,
      "mapping": "charm_option"
    },
    "dumpfile_location": {
      "type": "string",
      "description": "Path to a dumpfile to load into DB when service is initiated.\n",
      "default": "None",
      "mapping": "charm_option"
    },
    "effective_cache_size": {
      "type": "string",
      "description": "Effective cache size is an estimate of how much memory is available for disk caching within the database. (50% to 75% of system memory). This string should be of the format '###MB'. Ignored unless 'performance_tuning' is set to 'manual'.\n",
      "default": "",
      "mapping": "charm_option"
    },
    "encoding": {
      "type": "string",
      "description": "Default encoding used to store text in this service. Can only be set when deploying the first unit of a service.\n",
      "default": "UTF-8",
      "mapping": "charm_option"
    },
    "extra-packages": {
      "type": "string",
      "description": "Extra packages to install on the postgresql service units.",
      "default": "",
      "mapping": "charm_option"
    },
    "extra_archives": {
      "type": "string",
      "description": "DEPRECATED & IGNORED. Use install_sources and install_keys. \n",
      "default": "",
      "mapping": "charm_option"
    },
    "extra_pg_auth": {
      "type": "string",
      "description": "A comma separated extra pg_hba.conf auth rules. This will be written to the pg_hba.conf file, one line per rule. Note that this should not be needed as db relations already create those rules the right way. Only use this if you really need too (e.g. on a development environment), or are connecting juju managed databases to external managed systems, or configuring replication between unrelated PostgreSQL services using the manual_replication option.\n",
      "default": "",
      "mapping": "charm_option"
    },
    "fsync": {
      "type": "boolean",
      "description": "Turns forced synchronization on/off. If fsync is turned off, database failures are likely to involve database corruption and require recreating the unit\n",
      "default": true,
      "mapping": "charm_option"
    },
    "full_page_writes": {
      "type": "boolean",
      "description": "Recover from partial page writes.\n",
      "default": true,
      "mapping": "charm_option"
    },
    "hot_standby": {
      "type": "boolean",
      "description": "Hot standby or warm standby. When True, queries can be run against the database when in recovery or standby mode (ie. replicated). Overridden when service contains multiple units.\n",
      "default": false,
      "mapping": "charm_option"
    },
    "hot_standby_feedback": {
      "type": "boolean",
      "description": "Hot standby feedback, informing a master about in progress transactions on a streaming hot standby and allowing the master to defer cleanup and avoid query cancelations on the hot standby.\n",
      "default": false,
      "mapping": "charm_option"
    },
    "install_keys": {
      "type": "string",
      "description": "List of signing keys for install_sources package sources, per charmhelpers standard. YAML format.\n",
      "default": null,
      "mapping": "charm_option"
    },
    "install_sources": {
      "type": "string",
      "description": "List of extra package sources, per charm-helpers standard. YAML format.\n",
      "default": null,
      "mapping": "charm_option"
    },
    "kernel_shmall": {
      "type": "int",
      "description": "Total amount of shared memory available, in bytes.",
      "default": 0,
      "mapping": "charm_option"
    },
    "kernel_shmmax": {
      "type": "int",
      "description": "The maximum size, in bytes, of a shared memory segment.",
      "default": 0,
      "mapping": "charm_option"
    },
    "listen_ip": {
      "type": "string",
      "description": "IP to listen on",
      "default": "*",
      "mapping": "charm_option"
    },
    "listen_port": {
      "type": "int",
      "description": "Port to listen on. Default is automatically assigned.",
      "default": null,
      "mapping": "charm_option"
    },
    "locale": {
      "type": "string",
      "description": "Locale of service, defining language, default collation order, and default formatting of numbers, currency, dates & times. Can only be set when deploying the first unit of a service.\n",
      "default": "C",
      "mapping": "charm_option"
    },
    "log_autovacuum_min_duration": {
      "type": "int",
      "description": "-1 disables, 0 logs all actions and their durations, > 0 logs only actions running at least this number of milliseconds.\n",
      "default": -1,
      "mapping": "charm_option"
    },
    "log_checkpoints": {
      "type": "boolean",
      "description": "Log checkpoints",
      "default": false,
      "mapping": "charm_option"
    },
    "log_connections": {
      "type": "boolean",
      "description": "Log connections",
      "default": false,
      "mapping": "charm_option"
    },
    "log_disconnections": {
      "type": "boolean",
      "description": "Log disconnections",
      "default": false,
      "mapping": "charm_option"
    },
    "log_line_prefix": {
      "type": "string",
      "description": "special values:\n  %a = application name\n  %u = user name\n  %d = database name\n  %r = remote host and port\n  %h = remote host\n  %p = process ID\n  %t = timestamp without milliseconds\n  %m = timestamp with milliseconds\n  %i = command tag\n  %e = SQL state\n  %c = session ID\n  %l = session line number\n  %s = session start timestamp\n  %v = virtual transaction ID\n  %x = transaction ID (0 if none)\n  %q = stop here in non-session processes\n  %% = '%'\ne.g. '<%u%%%d> '\n",
      "default": "%t [%p]: [%l-1] db=%d,user=%u ",
      "mapping": "charm_option"
    },
    "log_lock_waits": {
      "type": "boolean",
      "description": "log lock waits >= deadlock_timeout",
      "default": false,
      "mapping": "charm_option"
    },
    "log_min_duration_statement": {
      "type": "int",
      "description": "-1 is disabled, 0 logs all statements and their durations, > 0 logs only statements running at least this number of milliseconds\n",
      "default": -1,
      "mapping": "charm_option"
    },
    "log_temp_files": {
      "type": "string",
      "description": "Log creation of temporary files larger than the threshold. -1 disables the feature, 0 logs all temporary files, or specify the threshold size with an optional unit (eg. \"512KB\", default unit is kilobytes).\n",
      "default": "-1",
      "mapping": "charm_option"
    },
    "log_timezone": {
      "type": "string",
      "description": "Log timezone",
      "default": "UTC",
      "mapping": "charm_option"
    },
    "maintenance_work_mem": {
      "type": "string",
      "description": "Maintenance working memory. Ignored unless 'performance_tuning' is set to 'manual'.\n",
      "default": "1MB",
      "mapping": "charm_option"
    },
    "manual_replication": {
      "type": "boolean",
      "description": "Enable or disable charm managed replication. When manual_replication is True, the operator is responsible for maintaining recovery.conf and performing any necessary database mirroring. The charm will still advertise the unit as standalone, master or hot standby to relations based on whether the system is in recovery mode or not. Note that this option makes it possible to create a PostgreSQL service with multiple master units, which is probably a very silly thing to do.\n",
      "default": false,
      "mapping": "charm_option"
    },
    "max_connections": {
      "type": "int",
      "description": "Maximum number of connections to allow to the PG database",
      "default": 100,
      "mapping": "charm_option"
    },
    "max_prepared_transactions": {
      "type": "int",
      "description": "Maximum number of prepared two phase commit transactions, waiting to be committed. Defaults to 0. as using two phase commit without a process to monitor and resolve lost transactions is dangerous.\n",
      "default": 0,
      "mapping": "charm_option"
    },
    "max_wal_senders": {
      "type": "int",
      "description": "Maximum number of hot standbys that can connect using streaming replication. Set this to the expected maximum number of hot standby units to avoid unnecessary blocking and database restarts. Overridden by juju if necessary.\n",
      "default": 0,
      "mapping": "charm_option"
    },
    "metrics_prefix": {
      "type": "string",
      "description": "Prefix for metrics. Special value $UNIT can be used to include the name of the unit in the prefix.\n",
      "default": "dev.$UNIT.postgresql",
      "mapping": "charm_option"
    },
    "metrics_sample_interval": {
      "type": "int",
      "description": "Period for metrics cron job to run in minutes",
      "default": 5,
      "mapping": "charm_option"
    },
    "metrics_target": {
      "type": "string",
      "description": "Destination for statsd-format metrics, format \"host:port\". If not present and valid, metrics disabled.\n",
      "default": "",
      "mapping": "charm_option"
    },
    "nagios_additional_servicegroups": {
      "type": "string",
      "description": "Used by the nrpe-external-master subordinate charm. A comma-separated list of servicegroups to include along with nagios_context when generating nagios service check configs. This is useful for nagios installations where servicegroups are used to apply special treatment to particular checks.\n",
      "default": "",
      "mapping": "charm_option"
    },
    "nagios_context": {
      "type": "string",
      "description": "Used by the nrpe-external-master subordinate charm. A string that will be prepended to instance name to set the host name in nagios. So for instance the hostname would be something like:\n    juju-postgresql-0\nIf you're running multiple environments with the same services in them this allows you to differentiate between them.\n",
      "default": "juju",
      "mapping": "charm_option"
    },
    "os_auth_url": {
      "type": "string",
      "description": "EXPERIMENTAL. OpenStack Swift authentication URL.",
      "default": null,
      "mapping": "charm_option"
    },
    "os_password": {
      "type": "string",
      "description": "EXPERIMENTAL. OpenStack Swift password.",
      "default": null,
      "mapping": "charm_option"
    },
    "os_tenant_name": {
      "type": "string",
      "description": "EXPERIMENTAL. OpenStack Swift tenant name.",
      "default": null,
      "mapping": "charm_option"
    },
    "os_username": {
      "type": "string",
      "description": "EXPERIMENTAL. OpenStack Swift username.",
      "default": null,
      "mapping": "charm_option"
    },
    "package_status": {
      "type": "string",
      "description": "The status of service-affecting packages will be set to this value in the dpkg database. Useful valid values are \"install\" and \"hold\".\n",
      "default": "install",
      "mapping": "charm_option"
    },
    "performance_tuning": {
      "type": "string",
      "description": "Possible values here are \"manual\", \"DW\" (data warehouse), \"OLTP\" (online transaction processing), \"Web\" (web application), \"Desktop\" or \"Mixed\". When this is set to a value other than \"manual\", the charm invokes the pgtune tool to tune a number of performance parameters based on the specified load type. pgtune gathers information about the node on which you are deployed and tries to make intelligent guesses about what tuning parameters to set based on available RAM and CPU under the assumption that it's the only significant service running on this node.\n",
      "default": "Mixed",
      "mapping": "charm_option"
    },
    "pgdg": {
      "type": "boolean",
      "description": "Enable the PostgreSQL Global Development Group APT repository (https://wiki.postgresql.org/wiki/Apt). This package source provides official PostgreSQL packages for Ubuntu LTS releases beyond those provided by the main Ubuntu archive.\n",
      "default": false,
      "mapping": "charm_option"
    },
    "random_page_cost": {
      "type": "float",
      "description": "Random page cost",
      "default": 4,
      "mapping": "charm_option"
    },
    "replicated_wal_keep_segments": {
      "type": "int",
      "description": "Value of wal_keep_segments used when this service is replicated. This setting only exists to provide a sane default when replication is requested (so it doesn't fail) and nobody bothered to change the wal_keep_segments setting.\n",
      "default": 5000,
      "mapping": "charm_option"
    },
    "search_path": {
      "type": "string",
      "description": "Comma separated list of schema names for the default SQL search path.\n",
      "default": "\"$user\",public",
      "mapping": "charm_option"
    },
    "shared_buffers": {
      "type": "string",
      "description": "The amount of memory the database server uses for shared memory buffers. This string should be of the format '###MB'. Ignored unless 'performance_tuning' is set to 'manual'.\n",
      "default": "",
      "mapping": "charm_option"
    },
    "ssl": {
      "type": "string",
      "description": "Whether PostgreSQL should talk SSL",
      "default": "True",
      "mapping": "charm_option"
    },
    "standard_conforming_strings": {
      "type": "boolean",
      "description": "Standard conforming strings",
      "default": true,
      "mapping": "charm_option"
    },
    "streaming_replication": {
      "type": "boolean",
      "description": "Enable streaming replication. Normally, streaming replication is always used, and any log shipping configured is used as a fallback. Turning this off without configuring log shipping is an error.\n",
      "default": true,
      "mapping": "charm_option"
    },
    "swiftwal_backup_retention": {
      "type": "int",
      "description": "EXPERIMENTAL. Number of recent base backups to retain. You need enough space in Swift for this many backups plus one more, as an old backup will only be removed after a new one has been successfully made to replace it.\n",
      "default": 2,
      "mapping": "charm_option"
    },
    "swiftwal_backup_schedule": {
      "type": "string",
      "description": "EXPERIMENTAL. Cron-formatted schedule for SwiftWAL database backups.\n",
      "default": null,
      "mapping": "charm_option"
    },
    "swiftwal_container_prefix": {
      "type": "string",
      "description": "EXPERIMENTAL. Swift container prefix for SwiftWAL to use. Must be set if any SwiftWAL features are enabled. This will become a simple swiftwal_container config item when proper leader election is implemented in juju.\n",
      "default": null,
      "mapping": "charm_option"
    },
    "swiftwal_log_shipping": {
      "type": "boolean",
      "description": "EXPERIMENTAL. Archive WAL files into Swift. If swiftwal_backup_schedule is set, allows point-in-time recovery and WAL files are removed automatically with old backups. If swiftwal_backup_schedule is not set then WAL files are never removed. Enabling this option will override the archive_mode and archive_command settings.\n",
      "default": false,
      "mapping": "charm_option"
    },
    "synchronous_commit": {
      "type": "boolean",
      "description": "Immediate fsync after commit.\n",
      "default": true,
      "mapping": "charm_option"
    },
    "temp_buffers": {
      "type": "string",
      "description": "The maximum number of temporary buffers used by each database session.\n",
      "default": "1MB",
      "mapping": "charm_option"
    },
    "version": {
      "type": "string",
      "description": "Version of PostgreSQL that we want to install. Supported versions are \"9.1\", \"9.2\", \"9.3\". The default version for the deployed Ubuntu release is used when the version is not specified.\n",
      "default": null,
      "mapping": "charm_option"
    },
    "wabs_access_key": {
      "type": "string",
      "description": "EXPERIMENTAL. Windows Azure access key.",
      "default": null,
      "mapping": "charm_option"
    },
    "wabs_account_name": {
      "type": "string",
      "description": "EXPERIMENTAL. Windows Azure account name.",
      "default": null,
      "mapping": "charm_option"
    },
    "wal_buffers": {
      "type": "string",
      "description": "min 32kB, -1 sets based on shared_buffers (change requires restart). Ignored unless 'performance_tuning' is set to 'manual'.\n",
      "default": "-1",
      "mapping": "charm_option"
    },
    "wal_e_backup_retention": {
      "type": "int",
      "description": "EXPERIMENTAL. Number of recent base backups and WAL files to retain. You need enough space for this many backups plus one more, as an old backup will only be removed after a new one has been successfully made to replace it.\n",
      "default": 2,
      "mapping": "charm_option"
    },
    "wal_e_backup_schedule": {
      "type": "string",
      "description": "EXPERIMENTAL. Cron-formatted schedule for WAL-E database backups. If wal_e_backup_schedule is unset, WAL files will never be removed from WAL-E storage.\n",
      "default": "13 0 * * *",
      "mapping": "charm_option"
    },
    "wal_e_storage_uri": {
      "type": "string",
      "description": "EXPERIMENTAL.\nSpecify storage to be used by WAL-E. Every PostgreSQL service must use\na unique URI. Backups will be unrecoverable if it is not unique. The\nURI's scheme must be one of 'swift' (OpenStack Swift), 's3' (Amazon AWS)\nor 'wabs' (Windows Azure). For example:\n  'swift://some-container/directory/or/whatever'\n  's3://some-bucket/directory/or/whatever'\n  'wabs://some-bucket/directory/or/whatever'\nSetting the wal_e_storage_uri enables regular WAL-E filesystem level\nbackups (per wal_e_backup_schedule), and log shipping to the configured\nstorage. Point-in-time recovery becomes possible, as is disabling the\nstreaming_replication configuration item and relying solely on\nlog shipping for replication.\n",
      "default": null,
      "mapping": "charm_option"
    },
    "wal_keep_segments": {
      "type": "int",
      "description": "Number of old WAL files to keep, providing a larger buffer for streaming hot standbys to catch up from when lagged. Each WAL file is 16MB in size. The WAL files are the buffer of how far a hot standby can lag behind the master, and replication fails if this buffer is overrun. When this service is replicated, the larger value of wal_keep_segments and replicated_wal_keep_segments is used.\n",
      "default": 0,
      "mapping": "charm_option"
    },
    "wal_level": {
      "type": "string",
      "description": "'minimal', 'archive' or 'hot_standby'. Defines how much information is written to the WAL. Set to 'minimal' for stand alone databases and 'hot_standby' for replicated setups. Overridden by juju when replication is used.\n",
      "default": "minimal",
      "mapping": "charm_option"
    },
    "work_mem": {
      "type": "string",
      "description": "Working Memory. Ignored unless 'performance_tuning' is set to 'manual'.\n",
      "default": "1MB",
      "mapping": "charm_option"
    }
  },
  "provides": [
    {
      "kind": "peer",
      "uri": "https://jujucharms.com/provides/block-storage",
      "juju_interface": "block-storage",
      "juju_name": "data",
      "juju_role": "provider",
      "juju_limit": 0
    },
    {
      "kind": "peer",
      "uri": "https://jujucharms.com/provides/pgsql",
      "juju_interface": "pgsql",
      "juju_name": "db",
      "juju_role": "provider",
      "juju_limit": 0
    },
    {
      "kind": "peer",
      "uri": "https://jujucharms.com/provides/pgsql",
      "juju_interface": "pgsql",
      "juju_name": "db-admin",
      "juju_role": "provider",
      "juju_limit": 0
    },
    {
      "kind": "peer",
      "uri": "https://jujucharms.com/provides/nrpe-external-master",
      "juju_interface": "nrpe-external-master",
      "juju_name": "nrpe-external-master",
      "juju_role": "provider",
      "juju_limit": 0
    }
  ],
  "juju_peers": {
    "replication": {
      "Name": "replication",
      "Role": "peer",
      "Interface": "pgreplication",
      "Optional": false,
      "Limit": 1,
      "Scope": "global"
    }
  },
  "license": "# Overview\n\n*excerpt from http://www.postgresql.org/about/*\n\nPostgreSQL is a powerful, open source object-relational database system.  It\nhas more than 15 years of active development and a proven architecture that has\nearned it a strong reputation for reliability, data integrity, and correctness.\nIt is fully ACID compliant, has full support for foreign keys, joins, views,\ntriggers, and stored procedures (in multiple languages). It includes most\nSQL:2008 data types, including INTEGER, NUMERIC, BOOLEAN, CHAR, VARCHAR, DATE,\nINTERVAL, and TIMESTAMP.  It also supports storage of binary large objects,\nincluding pictures, sounds, or video. It has native programming interfaces for\nC/C++, Java, .Net, Perl, Python, Ruby, Tcl, ODBC, among others, and\n[exceptional documentation](http://www.postgresql.org/docs/manuals/).\n\nAn enterprise class database, PostgreSQL boasts sophisticated features such as\nMulti-Version Concurrency Control (MVCC), point in time recovery, tablespaces,\nasynchronous replication, nested transactions (savepoints), online/hot backups,\na sophisticated query planner/optimizer, and write ahead logging for fault\ntolerance. It supports international character sets, multibyte character\nencodings, Unicode, and it is locale-aware for sorting, case-sensitivity, and\nformatting. It is highly scalable both in the sheer quantity of data it can\nmanage and in the number of concurrent users it can accommodate.  There are\nactive PostgreSQL systems in production environments that manage in excess of 4\nterabytes of data.\n\n# Usage\n\nThis charm supports several deployment models:\n\n - A single service containing one unit. This provides a 'standalone'\n   environment.\n\n - A service containing multiple units. One unit will be a 'master', and every\n   other unit is a 'hot standby'. The charm sets up and maintains replication\nfor you, using standard PostgreSQL streaming replication.\n\nTo setup a single 'standalone' service::\n\n    juju deploy postgresql pg-a\n\n\n## Scale Out Usage\n\nTo replicate this 'standalone' database to a 'hot standby', turning the\nexisting unit into a 'master'::\n\n    juju add-unit pg-a\n\nTo deploy a new service containing a 'master' and two 'hot standbys'::\n\n    juju deploy -n 2 postgresql pg-b\n    [ ... wait until units are stable ... ]\n    juju add-unit pg-b\n\nYou can remove units as normal. If the master unit is removed, failover occurs\nand the most up to date 'hot standby' is promoted to 'master'.  The\n'db-relation-changed' and 'db-admin-relation-changed' hooks are fired, letting\nclients adjust::\n\n    juju remove-unit pg-b/0\n\n\nTo setup a client using a PostgreSQL database, in this case a vanilla Django\ninstallation listening on port 8080::\n\n    juju deploy postgresql\n    juju deploy python-django\n    juju deploy gunicorn\n    juju add-relation python-django postgresql:db\n    juju add-relation python-django gunicorn\n    juju expose python-django\n\n\n## Known Limitations and Issues\n\n⚠ Due to current [limitations][1] with juju, you cannot reliably\ncreate a service initially containing more than 2 units (eg. juju deploy\n-n 3 postgresql). Instead, you must first create a service with 2 units.\nOnce the environment is stable and all the hooks have finished running,\nyou may add more units.\n\n⚠ Do not attempt to relate client charms to a PostgreSQL service containing\n  multiple units unless you know the charm supports a replicated service.\n\n⚠ To host multiple units on a single server, you must use an lxc\ncontainer.\n\n\n# Interacting with the Postgresql Service\n\nAt a minimum, you just need to join a the `db` relation, and a user and\ndatabase will be created for you.  For more complex environments, you can\nprovide the `database` name allowing multiple services to share the same\ndatabase. A client may also wish to defer its setup until the unit name is\nlisted in `allowed-units`, to avoid attempting to connect to a database before\nit has been authorized.\n\nThe `db-admin` relation may be used similarly to the `db` relation.  The\nautomatically generated user for `db-admin` relations is a PostgreSQL\nsuperuser.\n\n## Database Permissions and Disaster Recovery\n\n⚠ These two topics are entwined, because failing to follow best\n  practice with your database permissions will make your life difficult\n  when you need to recover after failure.\n\n_Always_ set the 'roles' relationship setting when joining a\nrelationship. _Always_ grant permissions to database roles for _all_\ndatabase objects your charm creates. _Never_ rely on access permissions\ngiven directly to a user, either explicitly or implicitly (such as being\nthe user who created a table). Consider the users you are provided by\nthe PostgreSQL charm as ephemeral. Any rights granted directly to them\nwill be lost if relations are recreated, as the generated usernames will\nbe different. _If you don't follow this advice, you will need to\nmanually repair permissions on all your database objects after any of\nthe available recovery mechanisms._\n\nLearn about the SQL `GRANT` statement in the excellect [PostgreSQL\nreference guide][3].\n\n### block-storage-broker\n\nIf you are using external storage provided by the block storage broker,\nrecovery or a failed unit is simply a matter of ensuring the old unit\nis fully shut down, and then bringing up a fresh unit with the old\nexternal storage mounted. The charm will see the old database there\nand use it.\n\nIf you are unable or do not wish to to simply remount the same\nfilesystem, you can of course copy all the data from the old filesystem\nto the new one before bringing up the new unit.\n\n### dump/restore\n\nPostgreSQL dumps, such as those that can be scheduled in the charm, can\nbe recovered on a new unit by using 'juju ssh' to connect to the new unit\nand using the standard PostgreSQL `pg_restore(1)` tool. This new unit must\nbe standalone, or the master unit. Any hot standbys will replicate the\nrecovered data from the master.\n\nYou will need to use `pg_restore(1)` with the `--no-owner` option, as\nusers that existed in the old service will not exist in the new\nservice.\n\n### PITR\n\nIf you had configured WAL-E, you can recover a WAL-E backup and replay\nto a point in time of your choosing using the `wal-e` tool. This\nwill recover the whole database cluster, so all databases will be\nreplaced.\n\nIf there are any hot standby units, they will need to be destroyed\nand recreated after the PITR recovery.\n\n\n## During db-relation-joined\n\n### the client service provides:\n\n- `database`: Optional. The name of the database to use. The postgresql service\n  will create it if necessary. If your charm sets this, then it must wait\n  until a matching `database` value is presented on the PostgreSQL side of\n  the relation (ie. `relation-get database` returns the value you set).\n- `roles`: Optional. A comma separated list of database roles to grant the\n  database user. Typically these roles will have been granted permissions to\n  access the tables and other database objects.  Do not grant permissions\n  directly to juju generated database users, as the charm may revoke them.\n- `extensions`: Optional. A comma separated list of required postgresql\n  extensions.\n\n## During db-relation-changed\n\n### the postgresql service provides:\n\n- `host`: the host to contact.\n- `database`: a regular database.\n- `port`: the port PostgreSQL is listening on.\n- `user`: a regular user authorized to read the database.\n- `password`: the password for `user`.\n- `state`: 'standalone', 'master' or 'hot standby'.\n- `allowed-units`: space separated list of allowed clients (unit name).  You\n  should check this to determine if you can connect to the database yet.\n\n## During db-admin-relation-changed\n\n### the postgresql service provides:\n\n- `host`: the host to contact\n- `port`: the port PostgreSQL is listening on\n- `user`: a created super user\n- `password`: the password for `user`\n- `state`: 'standalone', 'master' or 'hot standby'\n- `allowed-units`: space separated list of allowed clients (unit name).  You\n  should check this to determine if you can connect to the database yet.\n\n## During syslog-relation-changed\n\n### the postgresql service provides:\n\n- `programname`: the syslog 'programname' identifying this unit's\n  PostgreSQL logs.\n- `log_line_prefix`: the `log_line_prefix` setting for the PostgreSQL\n  service.\n\n\n## For replicated database support\n\nA PostgreSQL service may contain multiple units (a single master, and\noptionally one or more hot standbys). The client charm can tell which\nunit in a relation is the master and which are hot standbys by\ninspecting the 'state' property on the relation, and it needs to be\naware of how many units are in the relation by using the 'relation-list'\nhook tool.\n\nIf there is a single PostgreSQL unit related, the state will be\n'standalone'. All database connections of course go to this unit.\n\nIf there is more than one PostgreSQL unit related, the client charm\nmust only use units with state set to 'master' or 'hot standby'.\nThe unit with 'master' state can accept read and write connections. The\nunits with 'hot standby' state can accept read-only connections, and\nany attempted writes will fail. Units with any other state must not be\nused and should be ignored ('standalone' units are new units joining the\nservice that are not yet setup, and 'failover' state will occur when the\nmaster unit is being shutdown and a new master is being elected).\n\nThe client charm needs to watch for state changes in its\nrelation-changed hook. New units may be added to a single unit service,\nand the client charm must stop using existing 'standalone' unit and wait\nfor 'master' and 'hot standby' units to appear. Units may be removed,\npossibly causing a 'hot standby' unit to be promoted to a master, or\neven having the service revert to a single 'standalone' unit.\n\n\n## Example client hooks\n\nPython::\n\n    import sys\n    from charmhelpers.core.hookenv import (\n        Hooks, config, relation_set, relation_get,\n        local_unit, related_units, remote_unit)\n\n    hooks = Hooks()\n    hook = hooks.hook\n\n    @hook\n    def db_relation_joined():\n        relation_set('database', config('database'))  # Explicit database name\n        relation_set('roles', 'reporting,standard')  # DB roles required\n\n    @hook('db-relation-changed', 'db-relation-departed')\n    def db_relation_changed():\n        # Rather than try to merge in just this particular database\n        # connection that triggered the hook into our existing connections,\n        # it is easier to iterate over all active related databases and\n        # reset the entire list of connections.\n        conn_str_tmpl = \"dbname={dbname} user={user} host={host} port={port}\"\n        master_conn_str = None\n        slave_conn_strs = []\n        for db_unit in related_units():\n            if relation_get('database', db_unit) != config('database'):\n                continue  # Not yet acknowledged requested database name.\n\n            allowed_units = relation_get('allowed-units') or ''  # May be None\n            if local_unit() not in allowed_units.split():\n                continue  # Not yet authorized.\n\n            conn_str = conn_str_tmpl.format(**relation_get(unit=db_unit)\n            remote_state = relation_get('state', db_unit)\n\n            if remote_state == 'standalone' and len(active_db_units) == 1:\n                master_conn_str = conn_str\n            elif relation_state == 'master':\n                master_conn_str = conn_str\n            elif relation_state == 'hot standby':\n                slave_conn_strs.append(conn_str)\n\n        update_my_db_config(master=master_conn_str, slaves=slave_conn_strs)\n\n    if __name__ == '__main__':\n        hooks.execute(sys.argv)\n\n\n## Upgrade-charm hook notes\n\nThe PostgreSQL charm has deprecated volume-map and volume-ephemeral-storage\nconfiguration options in favor of using the storage subordinate charm for\ngeneral external storage management. If the installation being upgraded is\nusing these deprecated options, there are a couple of manual steps necessary \nto finish migration and continue using the current external volumes.\nEven though all data will remain intact, and PostgreSQL service will continue\nrunning, the upgrade-charm hook will intentionally fail and exit 1 as well to\nraise awareness of the manual procedure which will also be documented in the\njuju logs on the PostgreSQL units.\n\nThe following steps must be additionally performed to continue using external\nvolume maps for the PostgreSQL units once juju upgrade-charm is run from the\ncommand line:\n  1. cat > storage.cfg <<EOF\n     storage:\n       provider:block-storage-broker\n       root: /srv/data\n       volume_map: \"{postgresql/0: your-vol-id, postgresql/1: your-2nd-vol-id}\"\n     EOF\n  2. juju deploy --config storage.cfg storage\n  3. juju deploy block-storage-broker\n  4. juju add-relation block-storage-broker storage\n  5. juju resolved --retry postgresql/0   # for each postgresql unit running\n  6. juju add-relation postgresql storage\n\n\n# Point In Time Recovery\n\nThe PostgreSQL charm has experimental support for log shipping and point\nin time recovery. This feature uses the wal-e[2] tool, and requires access\nto Amazon S3, Microsoft Azure Block Storage or Swift. This feature is\nflagged as experimental because it has only been tested with Swift, and\nnot yet been tested under load. It also may require some API changes,\nparticularly on how authentication credentials are accessed when a standard\nemerges. The charm can be configured to perform regular filesystem backups\nand ship WAL files to the object store. Hot standbys will make use of the\narchived WAL files, allowing them to resync after extended netsplits or\neven let you turn off streaming replication entirely.\n\nWith a base backup and the WAL archive you can perform point in time\nrecovery, but this is still a manual process and the charm does not\nyet help you do it. The simplest approach would be to create a new\nPostgreSQL service containing a single unit, 'juju ssh' in and use\nwal-e to replace the database after shutting it down, create a\nrecovery.conf to replay the archived WAL files using wal-e, restart the\ndatabase and wait for it to recover. Once recovered, new hot standby\nunits can be added and client services related to the new database\nservice.\n\nTo enable the experimental wal-e support with Swift, you will need to\nuse Ubuntu 14.04 (Trusty), and set the service configuration settings\nsimilar to the following::\n\n    postgresql:\n        wal_e_storage_uri: swift://mycontainer\n        os_username: my_swift_username\n        os_password: my_swift_password\n        os_auth_url: https://keystone.auth.url.example.com:8080/v2/\n        os_tenant_name: my_tenant_name\n        install_sources: |\n            - ppa:stub/pgcharm\n            - cloud:icehouse\n\n\n# Contact Information\n\n## PostgreSQL \n\n- [PostgreSQL website](http://www.postgresql.org/)\n- [PostgreSQL bug submission\n  guidelines](http://www.postgresql.org/docs/9.2/static/bug-reporting.html)\n- [PostgreSQL Mailing List](http://www.postgresql.org/list/)\n\n  [1]: https://bugs.launchpad.net/charms/+source/postgresql/+bug/1258485\n  [2]: https://github.com/wal-e/wal-e\n  [3]: http://www.postgresql.org/docs/9.3/static/sql-grant.html\n",
  "readme": "# Overview\n\n*excerpt from http://www.postgresql.org/about/*\n\nPostgreSQL is a powerful, open source object-relational database system.  It\nhas more than 15 years of active development and a proven architecture that has\nearned it a strong reputation for reliability, data integrity, and correctness.\nIt is fully ACID compliant, has full support for foreign keys, joins, views,\ntriggers, and stored procedures (in multiple languages). It includes most\nSQL:2008 data types, including INTEGER, NUMERIC, BOOLEAN, CHAR, VARCHAR, DATE,\nINTERVAL, and TIMESTAMP.  It also supports storage of binary large objects,\nincluding pictures, sounds, or video. It has native programming interfaces for\nC/C++, Java, .Net, Perl, Python, Ruby, Tcl, ODBC, among others, and\n[exceptional documentation](http://www.postgresql.org/docs/manuals/).\n\nAn enterprise class database, PostgreSQL boasts sophisticated features such as\nMulti-Version Concurrency Control (MVCC), point in time recovery, tablespaces,\nasynchronous replication, nested transactions (savepoints), online/hot backups,\na sophisticated query planner/optimizer, and write ahead logging for fault\ntolerance. It supports international character sets, multibyte character\nencodings, Unicode, and it is locale-aware for sorting, case-sensitivity, and\nformatting. It is highly scalable both in the sheer quantity of data it can\nmanage and in the number of concurrent users it can accommodate.  There are\nactive PostgreSQL systems in production environments that manage in excess of 4\nterabytes of data.\n\n# Usage\n\nThis charm supports several deployment models:\n\n - A single service containing one unit. This provides a 'standalone'\n   environment.\n\n - A service containing multiple units. One unit will be a 'master', and every\n   other unit is a 'hot standby'. The charm sets up and maintains replication\nfor you, using standard PostgreSQL streaming replication.\n\nTo setup a single 'standalone' service::\n\n    juju deploy postgresql pg-a\n\n\n## Scale Out Usage\n\nTo replicate this 'standalone' database to a 'hot standby', turning the\nexisting unit into a 'master'::\n\n    juju add-unit pg-a\n\nTo deploy a new service containing a 'master' and two 'hot standbys'::\n\n    juju deploy -n 2 postgresql pg-b\n    [ ... wait until units are stable ... ]\n    juju add-unit pg-b\n\nYou can remove units as normal. If the master unit is removed, failover occurs\nand the most up to date 'hot standby' is promoted to 'master'.  The\n'db-relation-changed' and 'db-admin-relation-changed' hooks are fired, letting\nclients adjust::\n\n    juju remove-unit pg-b/0\n\n\nTo setup a client using a PostgreSQL database, in this case a vanilla Django\ninstallation listening on port 8080::\n\n    juju deploy postgresql\n    juju deploy python-django\n    juju deploy gunicorn\n    juju add-relation python-django postgresql:db\n    juju add-relation python-django gunicorn\n    juju expose python-django\n\n\n## Known Limitations and Issues\n\n⚠ Due to current [limitations][1] with juju, you cannot reliably\ncreate a service initially containing more than 2 units (eg. juju deploy\n-n 3 postgresql). Instead, you must first create a service with 2 units.\nOnce the environment is stable and all the hooks have finished running,\nyou may add more units.\n\n⚠ Do not attempt to relate client charms to a PostgreSQL service containing\n  multiple units unless you know the charm supports a replicated service.\n\n⚠ To host multiple units on a single server, you must use an lxc\ncontainer.\n\n\n# Interacting with the Postgresql Service\n\nAt a minimum, you just need to join a the `db` relation, and a user and\ndatabase will be created for you.  For more complex environments, you can\nprovide the `database` name allowing multiple services to share the same\ndatabase. A client may also wish to defer its setup until the unit name is\nlisted in `allowed-units`, to avoid attempting to connect to a database before\nit has been authorized.\n\nThe `db-admin` relation may be used similarly to the `db` relation.  The\nautomatically generated user for `db-admin` relations is a PostgreSQL\nsuperuser.\n\n## Database Permissions and Disaster Recovery\n\n⚠ These two topics are entwined, because failing to follow best\n  practice with your database permissions will make your life difficult\n  when you need to recover after failure.\n\n_Always_ set the 'roles' relationship setting when joining a\nrelationship. _Always_ grant permissions to database roles for _all_\ndatabase objects your charm creates. _Never_ rely on access permissions\ngiven directly to a user, either explicitly or implicitly (such as being\nthe user who created a table). Consider the users you are provided by\nthe PostgreSQL charm as ephemeral. Any rights granted directly to them\nwill be lost if relations are recreated, as the generated usernames will\nbe different. _If you don't follow this advice, you will need to\nmanually repair permissions on all your database objects after any of\nthe available recovery mechanisms._\n\nLearn about the SQL `GRANT` statement in the excellect [PostgreSQL\nreference guide][3].\n\n### block-storage-broker\n\nIf you are using external storage provided by the block storage broker,\nrecovery or a failed unit is simply a matter of ensuring the old unit\nis fully shut down, and then bringing up a fresh unit with the old\nexternal storage mounted. The charm will see the old database there\nand use it.\n\nIf you are unable or do not wish to to simply remount the same\nfilesystem, you can of course copy all the data from the old filesystem\nto the new one before bringing up the new unit.\n\n### dump/restore\n\nPostgreSQL dumps, such as those that can be scheduled in the charm, can\nbe recovered on a new unit by using 'juju ssh' to connect to the new unit\nand using the standard PostgreSQL `pg_restore(1)` tool. This new unit must\nbe standalone, or the master unit. Any hot standbys will replicate the\nrecovered data from the master.\n\nYou will need to use `pg_restore(1)` with the `--no-owner` option, as\nusers that existed in the old service will not exist in the new\nservice.\n\n### PITR\n\nIf you had configured WAL-E, you can recover a WAL-E backup and replay\nto a point in time of your choosing using the `wal-e` tool. This\nwill recover the whole database cluster, so all databases will be\nreplaced.\n\nIf there are any hot standby units, they will need to be destroyed\nand recreated after the PITR recovery.\n\n\n## During db-relation-joined\n\n### the client service provides:\n\n- `database`: Optional. The name of the database to use. The postgresql service\n  will create it if necessary. If your charm sets this, then it must wait\n  until a matching `database` value is presented on the PostgreSQL side of\n  the relation (ie. `relation-get database` returns the value you set).\n- `roles`: Optional. A comma separated list of database roles to grant the\n  database user. Typically these roles will have been granted permissions to\n  access the tables and other database objects.  Do not grant permissions\n  directly to juju generated database users, as the charm may revoke them.\n- `extensions`: Optional. A comma separated list of required postgresql\n  extensions.\n\n## During db-relation-changed\n\n### the postgresql service provides:\n\n- `host`: the host to contact.\n- `database`: a regular database.\n- `port`: the port PostgreSQL is listening on.\n- `user`: a regular user authorized to read the database.\n- `password`: the password for `user`.\n- `state`: 'standalone', 'master' or 'hot standby'.\n- `allowed-units`: space separated list of allowed clients (unit name).  You\n  should check this to determine if you can connect to the database yet.\n\n## During db-admin-relation-changed\n\n### the postgresql service provides:\n\n- `host`: the host to contact\n- `port`: the port PostgreSQL is listening on\n- `user`: a created super user\n- `password`: the password for `user`\n- `state`: 'standalone', 'master' or 'hot standby'\n- `allowed-units`: space separated list of allowed clients (unit name).  You\n  should check this to determine if you can connect to the database yet.\n\n## During syslog-relation-changed\n\n### the postgresql service provides:\n\n- `programname`: the syslog 'programname' identifying this unit's\n  PostgreSQL logs.\n- `log_line_prefix`: the `log_line_prefix` setting for the PostgreSQL\n  service.\n\n\n## For replicated database support\n\nA PostgreSQL service may contain multiple units (a single master, and\noptionally one or more hot standbys). The client charm can tell which\nunit in a relation is the master and which are hot standbys by\ninspecting the 'state' property on the relation, and it needs to be\naware of how many units are in the relation by using the 'relation-list'\nhook tool.\n\nIf there is a single PostgreSQL unit related, the state will be\n'standalone'. All database connections of course go to this unit.\n\nIf there is more than one PostgreSQL unit related, the client charm\nmust only use units with state set to 'master' or 'hot standby'.\nThe unit with 'master' state can accept read and write connections. The\nunits with 'hot standby' state can accept read-only connections, and\nany attempted writes will fail. Units with any other state must not be\nused and should be ignored ('standalone' units are new units joining the\nservice that are not yet setup, and 'failover' state will occur when the\nmaster unit is being shutdown and a new master is being elected).\n\nThe client charm needs to watch for state changes in its\nrelation-changed hook. New units may be added to a single unit service,\nand the client charm must stop using existing 'standalone' unit and wait\nfor 'master' and 'hot standby' units to appear. Units may be removed,\npossibly causing a 'hot standby' unit to be promoted to a master, or\neven having the service revert to a single 'standalone' unit.\n\n\n## Example client hooks\n\nPython::\n\n    import sys\n    from charmhelpers.core.hookenv import (\n        Hooks, config, relation_set, relation_get,\n        local_unit, related_units, remote_unit)\n\n    hooks = Hooks()\n    hook = hooks.hook\n\n    @hook\n    def db_relation_joined():\n        relation_set('database', config('database'))  # Explicit database name\n        relation_set('roles', 'reporting,standard')  # DB roles required\n\n    @hook('db-relation-changed', 'db-relation-departed')\n    def db_relation_changed():\n        # Rather than try to merge in just this particular database\n        # connection that triggered the hook into our existing connections,\n        # it is easier to iterate over all active related databases and\n        # reset the entire list of connections.\n        conn_str_tmpl = \"dbname={dbname} user={user} host={host} port={port}\"\n        master_conn_str = None\n        slave_conn_strs = []\n        for db_unit in related_units():\n            if relation_get('database', db_unit) != config('database'):\n                continue  # Not yet acknowledged requested database name.\n\n            allowed_units = relation_get('allowed-units') or ''  # May be None\n            if local_unit() not in allowed_units.split():\n                continue  # Not yet authorized.\n\n            conn_str = conn_str_tmpl.format(**relation_get(unit=db_unit)\n            remote_state = relation_get('state', db_unit)\n\n            if remote_state == 'standalone' and len(active_db_units) == 1:\n                master_conn_str = conn_str\n            elif relation_state == 'master':\n                master_conn_str = conn_str\n            elif relation_state == 'hot standby':\n                slave_conn_strs.append(conn_str)\n\n        update_my_db_config(master=master_conn_str, slaves=slave_conn_strs)\n\n    if __name__ == '__main__':\n        hooks.execute(sys.argv)\n\n\n## Upgrade-charm hook notes\n\nThe PostgreSQL charm has deprecated volume-map and volume-ephemeral-storage\nconfiguration options in favor of using the storage subordinate charm for\ngeneral external storage management. If the installation being upgraded is\nusing these deprecated options, there are a couple of manual steps necessary \nto finish migration and continue using the current external volumes.\nEven though all data will remain intact, and PostgreSQL service will continue\nrunning, the upgrade-charm hook will intentionally fail and exit 1 as well to\nraise awareness of the manual procedure which will also be documented in the\njuju logs on the PostgreSQL units.\n\nThe following steps must be additionally performed to continue using external\nvolume maps for the PostgreSQL units once juju upgrade-charm is run from the\ncommand line:\n  1. cat > storage.cfg <<EOF\n     storage:\n       provider:block-storage-broker\n       root: /srv/data\n       volume_map: \"{postgresql/0: your-vol-id, postgresql/1: your-2nd-vol-id}\"\n     EOF\n  2. juju deploy --config storage.cfg storage\n  3. juju deploy block-storage-broker\n  4. juju add-relation block-storage-broker storage\n  5. juju resolved --retry postgresql/0   # for each postgresql unit running\n  6. juju add-relation postgresql storage\n\n\n# Point In Time Recovery\n\nThe PostgreSQL charm has experimental support for log shipping and point\nin time recovery. This feature uses the wal-e[2] tool, and requires access\nto Amazon S3, Microsoft Azure Block Storage or Swift. This feature is\nflagged as experimental because it has only been tested with Swift, and\nnot yet been tested under load. It also may require some API changes,\nparticularly on how authentication credentials are accessed when a standard\nemerges. The charm can be configured to perform regular filesystem backups\nand ship WAL files to the object store. Hot standbys will make use of the\narchived WAL files, allowing them to resync after extended netsplits or\neven let you turn off streaming replication entirely.\n\nWith a base backup and the WAL archive you can perform point in time\nrecovery, but this is still a manual process and the charm does not\nyet help you do it. The simplest approach would be to create a new\nPostgreSQL service containing a single unit, 'juju ssh' in and use\nwal-e to replace the database after shutting it down, create a\nrecovery.conf to replay the archived WAL files using wal-e, restart the\ndatabase and wait for it to recover. Once recovered, new hot standby\nunits can be added and client services related to the new database\nservice.\n\nTo enable the experimental wal-e support with Swift, you will need to\nuse Ubuntu 14.04 (Trusty), and set the service configuration settings\nsimilar to the following::\n\n    postgresql:\n        wal_e_storage_uri: swift://mycontainer\n        os_username: my_swift_username\n        os_password: my_swift_password\n        os_auth_url: https://keystone.auth.url.example.com:8080/v2/\n        os_tenant_name: my_tenant_name\n        install_sources: |\n            - ppa:stub/pgcharm\n            - cloud:icehouse\n\n\n# Contact Information\n\n## PostgreSQL \n\n- [PostgreSQL website](http://www.postgresql.org/)\n- [PostgreSQL bug submission\n  guidelines](http://www.postgresql.org/docs/9.2/static/bug-reporting.html)\n- [PostgreSQL Mailing List](http://www.postgresql.org/list/)\n\n  [1]: https://bugs.launchpad.net/charms/+source/postgresql/+bug/1258485\n  [2]: https://github.com/wal-e/wal-e\n  [3]: http://www.postgresql.org/docs/9.3/static/sql-grant.html\n",
  "readme_name": "README.md",
  "gatherbase_origin": "juju-charmstore"
}