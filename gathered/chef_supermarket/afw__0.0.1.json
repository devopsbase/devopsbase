{
  "name": "afw Chef cookbook",
  "chef_cookbook_name": "afw",
  "revision": "0.0.1",
  "uris": [
    "https://supermarket.chef.io/cookbooks/afw",
    "https://supermarket.chef.io/cookbooks/afw/download",
    "https://supermarket.chef.io/cookbooks/afw/versions/0.0.1",
    "https://supermarket.chef.io/cookbooks/afw/versions/0.0.1/download",
    "https://supermarket.chef.io/api/v1/cookbooks/afw/versions/0.0.1",
    "https://supermarket.chef.io/api/v1/cookbooks/afw",
    "https://supermarket.chef.io/api/v1/cookbooks/afw/versions/0.0.1/download"
  ],
  "labels": [
    "Chef cookbook",
    "Networking",
    "Executable/Script/Chef Cookbook",
    "Mode/Executable/Script/Chef Cookbook"
  ],
  "info_url": "https://supermarket.chef.io/cookbooks/afw",
  "package_url": "https://supermarket.chef.io/api/v1/cookbooks/afw/versions/0.0.1/download",
  "deprecated": false,
  "created": "2012-09-16T20:49:48.000Z",
  "updated": "2013-04-10T19:55:09.000Z",
  "description": "Installs/Configures the Advanced FireWall",
  "maintainer": {
    "name": "jvehent",
    "email": "julienv@aweber.com"
  },
  "license": "All rights reserved",
  "chef_foodcritic_failure": null,
  "chef_up_for_adoption": null,
  "rating": null,
  "followers_count": 3,
  "downloads_count": 7892582,
  "downloads_count_revision": 1315310,
  "repository_url": "https://github.com/jvehent/afw/",
  "issues_url": "https://github.com/jvehent/afw/",
  "chef_source_url": "https://github.com/jvehent/afw/",
  "gatherbase_origin": "chef-supermarket",
  "readme_name": "README.md",
  "readme": "# The AWeber Firewall (afw)\n\n__A__{dvanced|Weber|wesome} FireWall (AFW) for Linux that uses Iptables and\nChef to dynamically configure inbound and outbound rules on each node.\n\n## Dependencies\n### Ohai network_addr\nThis cookbooks depends on the custom AWeber Ohai plugin which sets the two\nfollowing attributes:\n`node[:network][:lanip]` is set to the IP of the node on the LAN network\n`node[:network][:laniface]` is set to the network interface on the LAN\n\n## Rules definitions\nRules must be added in roles or nodes attributes. A typical rule looks like:\n\n```\n:afw =>\n  :rules =>\n    \"SIP Trunk Ports (UDP) - VoicePulse Secondary\" =>\n      :direction => 'in',\n      :interface => 'default',\n      :protocol => 'udp',\n      :user => 'asterisk',\n      :source => '209.31.18.12',\n      :port => '10000:20000'\n}\n\n```\n\nRules must be added into `node[:afw][:rules]`, and follow this syntax:\n\n```\n\n:afw =>\n  :rules =>\n    '<rule name>' =>\n      :direction => '<in|out>',\n      :protocol => '<udp|tcp|icmp>',\n      :user => '<local user from /etc/passwd>',\n      :interface => '<default|all|eth0|eth1|br0|...>',\n      :source => '<ip|fqdn|chef search>|['<ip|fqdn|chef search>',...]'>',\n      :sport => '<integer(:integer))>',\n      :destination => '<ip|fqdn|chef search>|['<ip|fqdn|chef search>',...]'>',\n      :dport => '<integer(:integer)>',\n      :conntrack => '<on|off>',\n      :raw => '<iptables-save raw rule>',\n      :env => '<production|staging|all|...>'\n}\n\n```\n\n* __Rule Name__ : A `string` that identifies the rule as uniquely as possible.\n\n* __direction__ (__mandatory__): `in` is for inbound firewall rules.\n`out` for outbound firewall rules.\nSelect whether the rule will apply to packets entering the system (`in`) or\nleaving it (`out`).\n\n* __protocol__ (__mandatory__):\nSelect the L4 protocol this rule applies to: `udp`, `tcp` or `icmp`.\n\n* __user__ (___mandatory___):\nSet the local user allowed to transmit packets. The user is checked only for\noutbound firewall rules (iptables limitation) but must be set for inbound\nrules as well, to ease auditing rules & systems.\nNote: if the local user doesn't exists, the provisioning will fail at the end,\nwhen the rules are loaded. If the user is installed by a package, the next chef\nrun will succeed and fix the issue.\n\n* __dport__ (__mandatory__):\nSet the destination port of the connections being filtered. This is mandatory.\nExcept when it's not (eg. icmp).\n\n* __interface__ (*optional*):\nSelect the network interface. If undef, the default interface will be used.\nif `all`, the interface parameter won't be set at all.\n\n* __source__ (__mandatory for `in` rules__):\nSet the source IP of the packets. This parameter can either be a single IP or\nnetwork (eg. `10.1.2.0/32`), a Fully Qualified Domain Name (eg. `bob.colo.lair`)\n or a Chef Search (eg. `roles:mongodb`).\nBy default, searches are limited to the same `chef_environment` (eg. staging),\nto allow for firewall rules that open connections between environments, you\nwill need an `heresy` parameter.\nIn a chef-search, you can also use they keyword `SAMETAG` that will limit the\nsearch to the nodes that share the same tags. This is useful if, for example,\nyou want to open connections to a database from all nodes within the same\nservice tag, but not beyond.\nThe syntax for a search would look like: 'roles:whatever-api AND SAMETAG'.\nIf you have multiple sources and destinations, you can set them in a array:\n```\n'AMQP Producers' => {\n  :direction => 'in',\n  :user => 'rabbitmq',\n  :protocol => 'tcp',\n  :interface => 'default',\n  :source => ['producer1.internal.domain.com',\n              'producer2.internal.domain.com',\n              '192.168.1.1',\n              'roles:megaserver'],\n  :dport => '5672'\n}\n```\n\n* __destination__ (*Same as `source`*)\n\n* __sport__ (*optional*):\nSet the source port in the firewall rule. For `in` rules, that means the source\nport of the remote machine. For `out` rules, that means the source port of this\nnode when establishing a connection to a remote node.\n\n* __env__ (*optional*):\nThe env parameters can be used to limit the application of a rule to a specific\nenvironment. If `:env => 'staging'` is set, the rule will be applied to nodes in\nthe staging environment only.\nEnv can also be used to cross environment. If `:env => 'all'` is set, the rule\nwill be applied everywhere, and accept connection (to destinations|from sources)\nthat are in any `chef_environment`. Thus, the following rule will allow workers\nto connect to BackendDB in both staging and production. This is dangerous, don't\ndo that. Keep your environments isolated as much as possible.\n```\n      'Worker to BackendDB' => {\n        :protocol => 'tcp',\n        :direction => 'out',\n        :user => 'application-user',\n        :destination => 'roles:*backenddb* AND SAMETAG',\n        :dport => '15017',\n        :env => 'all'\n      }\n```\n\n### Predefined rules\nPredefined rules are iptables rules that are used directly by AFW. Those rules\nare used for specific purposes only, such as using a very particular module for\nwhich AFW wouldn't have any support.\nPredefined rules only support 2 arguments: `table` and `rule`.\n\n* __table__:\nthe netfilter table on which this rule must be applied. One of `nat`, `raw`,\n`mangle` or `filter.\n\n* __rule__: the firewall rule itself, in iptables-save format (do not specify\na table in this format, or it will fail).\n\nexample:\n```\n  :afw => {\n    :rules => {\n\n      'Accept all packets router through the bridge' => {\n        :table => 'filter',\n        :rule => '-I FORWARD -o br0 -m physdev --physdev-is-bridged -j ACCEPT'\n      },\n\n      'Drop connection to the admin panel on the eth0 interface' => {\n        :table => 'mangle',\n        :rule => '-A INPUT -i eth0 -p tcp --dport 80 -m string --string \"get /admin http/1.1\" --icase --algo bm -m conntrack --ctstate ESTABLISHED -j DROP'\n      },\n\n      'DNAT a source IP to change the destination port' => {\n        :table => 'nat',\n        :rule => '-A PREROUTING -i eth3 -s 201.23.72.3 -p tcp --dport 8008 -j DNAT --to-destination 127.0.0.1:1234'\n      },\n\n      'Dont do conntrack on this specific user's UDP packets' => {\n        :table => 'raw',\n        :rule => '-A OUTPUT -o eth0 -p udp -m owner --uid-owner 105 -j NOTRACK'\n      }\n    }\n  }\n```\n\n## Behavior\n\nThe recipe will generate a rule file in `/etc/firewall/rules.iptables` that\nconforms to the iptables-save/restore syntax.\nAt the end of the chef-run, and if the rules file has been modified during the\nrun, the `iptables-restore` command will reload the entire ruleset.\n\nHere's an example of ruleset\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n 698K   35M ACCEPT     all  --  lo     any     anywhere             anywhere\n34569   25M ACCEPT     all  --  any    any     anywhere             anywhere            state RELATED,ESTABLISHED\n    5   220 ACCEPT     tcp  --  any    any     anywhere             anywhere            tcp dpt:ssh\n    0     0 ACCEPT     udp  --  eth1   any     anywhere             anywhere            udp dpt:1514 state NEW\n    0     0 ACCEPT     udp  --  eth1   any     10.212.0.233         anywhere            udp dpt:1514 state NEW\n    0     0 ACCEPT     tcp  --  eth1   any     anywhere             anywhere            tcp dpts:8649:8699 state NEW\n    0     0 ACCEPT     udp  --  eth1   any     239.2.11.0/24        anywhere            udp dpts:8649:8699 state NEW\n    0     0 ACCEPT     tcp  --  eth1   any     10.212.0.233         anywhere            tcp dpts:8649:8699 state NEW\n36743 3540K DROP       all  --  any    any     anywhere             anywhere\n\nChain OUTPUT (policy ACCEPT 31184 packets, 2587K bytes)\n pkts bytes target     prot opt in     out     source               destination\n 698K   35M ACCEPT     all  --  any    lo      anywhere             anywhere\n15851 1390K ACCEPT     all  --  any    any     anywhere             anywhere            state RELATED,ESTABLISHED\n  127  7601 ACCEPT     udp  --  any    any     anywhere             anywhere            udp dpt:domain\n  492 35360 ossec      all  --  any    any     anywhere             anywhere            owner UID match root state NEW\n  492 35360 root       all  --  any    any     anywhere             anywhere            owner UID match root state NEW\n    0     0 ganglia    all  --  any    any     anywhere             anywhere            owner UID match root state NEW\n\nChain ganglia (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 ACCEPT     udp  --  any    eth1    anywhere             239.2.11.0/24       udp dpts:8649:8699 state NEW\n    0     0 LOG        all  --  any    any     anywhere             anywhere            LOG level warning tcp-sequence uid prefix `ganglia DROP '\n\nChain ossec (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 ACCEPT     udp  --  any    eth1    anywhere             anywhere            udp dpt:1514 state NEW\n    0     0 ACCEPT     udp  --  any    eth1    anywhere             10.212.0.233        udp dpt:1514 state NEW\n  492 35360 LOG        all  --  any    any     anywhere             anywhere            LOG level warning tcp-sequence uid prefix `ossec DROP '\n\nChain root (1 references)\n pkts bytes target     prot opt in     out     source               destination\n  113  6780 ACCEPT     tcp  --  any    eth1    anywhere             chef.local.vm       tcp dpt:4000 state NEW\n   14   840 ACCEPT     tcp  --  any    any     anywhere             anywhere            tcp dpts:tcpmux:65535 state NEW\n  365 27740 ACCEPT     udp  --  any    any     anywhere             anywhere            udp dpts:1:65535 state NEW\n    0     0 ACCEPT     icmp --  any    any     anywhere             anywhere            state NEW\n    0     0 LOG        all  --  any    any     anywhere             anywhere            LOG level warning tcp-sequence uid prefix `root DROP '\n```\n\nThe `INPUT` chain contains all of the rules for incoming connections. It does\nnot redirect packets to other chains, but accept or drop them directly.\n\nThe `OUTPUT` chain is a little different. Depending on the owner of the socket\nemitting packets, it will direct the packets to a different chain, named after\nthe socket owner.\nIn the example above, the packet from the `ossec` user will be directed to the\nchain named `ossec`. You can see in this chain that the first two rules accept\npacket, while the 3rd one will `LOG` to syslog when it is reached (it shouldn't\nbe). Eventually, a `DROP` will follow that log rule to drop packets that aren't\nsuppose to be sent.\n\n\n",
  "requires": [
    {
      "kind": "env",
      "uri": "https://supermarket.chef.io/cookbooks/ohai",
      "revision": ">= 0.0.0",
      "self_resolve": true
    }
  ]
}