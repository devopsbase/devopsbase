{
  "name": "smf Chef cookbook",
  "chef_cookbook_name": "smf",
  "revision": "0.6.9",
  "uris": [
    "https://supermarket.chef.io/cookbooks/smf",
    "https://supermarket.chef.io/cookbooks/smf/download",
    "https://supermarket.chef.io/cookbooks/smf/versions/0.6.9",
    "https://supermarket.chef.io/cookbooks/smf/versions/0.6.9/download",
    "https://supermarket.chef.io/api/v1/cookbooks/smf/versions/0.6.9",
    "https://supermarket.chef.io/api/v1/cookbooks/smf",
    "https://supermarket.chef.io/api/v1/cookbooks/smf/versions/0.6.9/download"
  ],
  "labels": [
    "Chef cookbook",
    "Process Management",
    "Executable/Script/Chef Cookbook",
    "Binding/Provider",
    "Mode/Executable/Script/Chef Cookbook"
  ],
  "info_url": "https://supermarket.chef.io/cookbooks/smf",
  "package_url": "https://supermarket.chef.io/api/v1/cookbooks/smf/versions/0.6.9/download",
  "deprecated": false,
  "created": "2012-10-28T20:39:17.000Z",
  "updated": "2016-02-18T09:18:04.902Z",
  "description": "A light weight resource provider (LWRP) for SMF (Service Management Facility)",
  "maintainer": {
    "name": "sax",
    "email": "ops@modcloth.com"
  },
  "license": "Apache 2.0",
  "chef_foodcritic_failure": true,
  "chef_up_for_adoption": null,
  "rating": null,
  "followers_count": 10,
  "downloads_count": 33339302,
  "downloads_count_revision": 1259648,
  "gatherbase_origin": "chef-supermarket",
  "readme_name": "README.md",
  "readme": "# SMF\n\n## Description\n\nService Management Facility (SMF) is a tool in many Illumos and Solaris-derived operating systems\nthat treats services as first class objects of the system. It provides an XML syntax for \ndeclaring how the system can interact with and control a service.\n\nThe SMF cookbook contains providers for creating or modifying a service within the SMF framework.\n\n## Requirements\n\nAny operating system that uses SMF, ie Solaris, SmartOS, OpenIndiana etc.\n\nRequires the RBAC cookbook, which can be found at https://github.com/modcloth-cookbooks/rbac.git\n\nProcesses can be run inside a project wrapper. In this case, look to the Resource Control cookbook,\nwhich can be found at https://github.com/wanelo-chef/resource-control. Note that the SMF LWRP\ndoes not create or manage the project.\n\n## Attributes\n\n* `user` - User to run service commands as\n* `group` - Group to run service commands as\n* `project` - Name of project to run commands in\n* `start_command`\n* `start_timeout`\n* `stop_command` - defaults to `:kill`, which basically means it will destroy every PID generated from the start command\n* `stop_timeout`\n* `restart_command` - defaults to `stop_command`, then `start_command`\n* `restart_timeout`\n* `working_directory` - PWD that SMF should cd to in order to run commands\n* `duration` - Can be either `contract`, `wait`, `transient` or `child`, but defaults to `contract`. See the Duration section below.\n* `locale` - Character encoding to use (default \"C\")\n* `environment` - Hash - Environment variables to set while running commands\n* `service_path` - defaults to `/var/svc/manifest`\n* `manifest_type` - defaults to `application`\n* `property_groups` - Hash - This should be in the form `{\"group name\" => {\"type\" => \"application\", \"key\" => \"value\", ...}}`\n* `ignore` - Array - Faults to ignore in subprocesses. For example, if core dumps in children are handled by a master process and you don't want SMF thinking the service is exploding, you can ignore [\"core\", \"signal\"].\n* `credentials_user` - deprecated in favor of `user`\n\n## Usage\n\n```ruby\nsmf \"my-service\" do\n  user \"non-root-user\"\n  start_command \"my-service start\"\n  start_timeout 10\n  stop_command \"pkill my-service\"\n  stop_command  5\n  restart_command \"my-service restart\"\n  restart_timeout 60\n  environment \"PATH\" => \"/home/non-root-user/bin\",\n              \"RAILS_ENV\" => \"staging\"\n  locale \"C\"\n  manifest_type \"application\"\n  service_path  \"/var/svc/manifest\"\nend\n\nservice \"my-service\" do\n  action :enable\nend\n\nservice \"my-service\" do\n  action :restart\nend\n```\n\n## Provider Actions\n\n### :install (default)\n\nThis will drop a manifest XML file into `#{service_path}/#{manifest_type}/#{name}.xml`. If there is already a service\nwith a name that is matched by `new_resource.name` then the FMRI of our manifest will be set to the FMRI of the \npre-existing service. In this case, our properties will be merged into the properties of the pre-existing service.\n\nIn this way, updates to recipes that use the SMF provider will not delete existing service properties, but will add \nor overwrite them.\n\nBecause of this, the SMF provider can be used to update properties for\nservices that are installed via a package manager.\n\n### :delete\n\nRemove an SMF definition. This stops the service if it is running.\n\n## Resource Notes\n\n### `user`, `working_directory` and `environment`\n\nSMF does a remarkably good job running services as delegated users, and removes a lot of pain if you configure a \nservice correctly. There are many examples online (blogs, etc) of users wrapping their services in shell scripts with \n`start`, `stop`, `restart` arguments. In general it seems as if the intention of these scripts is to take care of the\nproblem of setting environment variables and shelling out as another user.\n\nThe use of shell scripts to wrap executables is unnecessary with SMF, as it provides hooks for all of these use cases. \nWhen using `user`, SMF will assume that the `working_directory` is the user's home directory. This can be\neasily overwritten (to `/home/user/app/current` for a Rails application, for example). One thing to be careful of is \nthat shell profile files will not be loaded. For this reason, if environment variables (such as PATH) are different \non your system or require additional entries arbitrary key/values may be set using the `environment` attribute.\n\n### Duration\n\nThere are several different ways that SMF can track your service. By default it uses `contract`. \nBasically, this means that it will keep track of the PIDs of all daemonized processes generated from `start_command`.\nIf SMF sees that processes are cycling, it may try to restart the service. If things get too hectic, it\nmay think that your service is flailing and put it into maintenance mode. If this is normal for your service,\nfor instance if you have a master that occasionally reaps processes, you may want to specify additional\nconfiguration options.\n\nIf you have a job that you want managed by SMF, but which is not daemonized, another duration option is\n`transient`. In this mode, SMF will not watch any processes, but will expect that the main process exits cleanly.\nThis can be used, for instance, for a script that must be run at boot time, or for a script that you want to delegate\nto particular users with Role Based Access Control. In this case, the script can be registered with SMF to run as root,\nbut with the start_command delegated to your user.\n\nA third option is `wait`. \n\nA fourth option is `child`.\n\n### Ignore\n\nSometimes you have a case where your service behaves poorly. The Ruby server Unicorn, for example, has a master \nprocess that likes to kill its children. This causes core dumps that SMF will interpret to be a failing service.\nInstead you can `ignore [\"core\", \"signal\"]` and SMF will stop caring about core dumps.\n\n### Property Groups\n\nProperty Groups are where you can store extra information for SMF to use later. They should be used in the\nfollowing format:\n\n```ruby\nsmf \"my-service\" do\n  start_command \"do-something\"\n  property_groups({\n    \"config\" => {\n      \"type\" => \"application\",\n      \"my-property\" => \"property value\"\n    }\n  })\nend\n```\n\n`type` will default to `application`, and is used in the manifest XML to declare how the property group will be\nused. For this reason, `type` can not be used as a property name (ie variable).\n\nOne way to use property groups is to pass variables on to commands, as follows:\n\n```ruby\nrails_env = node[\"from-chef-environment\"][\"rails-env\"]\n\nsmf \"unicorn\" do\n  start_command \"bundle exec unicorn_rails -c /home/app_user/app/current/config/%{config/rails_env} -E %{config/rails_env} -D\"\n  start_timeout 300\n  restart_command \":kill -SIGUSR2\"\n  restart_timeout 300\n  working_directory \"/home/app_user/app/current\"\n  property_groups({\n    \"config\" => {\n      \"rails_env\" => rails_env\n    }\n  })\nend\n```\n\nThis is especially handy if you have a case where your commands may come from role attributes, but can\nonly work if they have access to variables set in an environment or computed in a recipe.\n\n## Working Examples\n\nBelow are some of the working examples using the SMF cookbook.\n\n### Shared Helpers\n\nThese live in a library provider somewhere, and help start/stop pid-based processes. This strategy may\nbe required when using the `wait` duration.\n\n```ruby\nmodule ProcessHelpers\n  def start_helper(cmd)\n    \"#{node[:bash]} -c 'export HOME=/home/#{node[:app][:user]} && export JAVA_HOME=/opt/local/java/sun6/ && export PATH=$JAVA_HOME/bin:/opt/local/bin:/opt/local/sbin:/usr/bin:/usr/sbin:$PATH && source $HOME/.bashrc && cd $HOME/#{node[:app][:dir]} && #{cmd}'\"\n  end\n  def stop_helper(pid, sig = :term)\n    \"#{node[:bash]} -c 'if [ -f #{pid} ]; then kill -#{sig.to_s.upcase} `cat #{pid}` 2>/dev/null; fi; exit 0'\"\n  end\nend\n```\n\n### Unicorn\n\nHere is an example that uses duration `wait`. Because of this, SMF does\nnot watch pids in a contract, and the `stop_command` needs to figure out\nwhat processes are running.\n\n```ruby\nclass Chef::Resource::Smf\n  include ::ProcessHelpers\nend\n\nrails_env     = node[:rails_env]\nuser          = node[:app][:user]\n\ncurrent_path  = \"/home/#{user}/#{node[:app][:dir]}\"\nunicorn_conf  = \"#{current_path}/config/unicorn/#{rails_env}.rb\"\nunicorn_pid   = \"#{current_path}/tmp/pids/unicorn.pid\"\n\nsmf \"unicorn\" do\n  user user\n  start_command start_helper(\"(bundle exec unicorn_rails -c #{unicorn_conf} -E #{rails_env} -D)\")\n  start_timeout 90\n  stop_command stop_helper(unicorn_pid, :term)\n  stop_timeout 30\n  duration \"wait\"\n  working_directory \"#{current_path}\"\nend\n```\n\nThis example, while more verbose, uses the default duration of\n`contract`, and so SMF can take care of pid management. We are able to\nuse `:kill` in the stop and restart commands.\n\n```ruby\ncurrent_path = \"/home/#{user}/#{node.app.dir}\"\nrails_env = node.app.rails_env\nunicorn_path = \"/home/#{user}/.rbenv/shims:/home/#{user}/.rbenv/bin\"\ngarbage_collection_settings = {\n  \"RUBY_GC_MALLOC_LIMIT\": 50000000,\n  \"RUBY_HEAP_MIN_SLOTS\": 500000,\n  \"RUBY_HEAP_SLOTS_GROWTH_FACTOR\": 1,\n  \"RUBY_HEAP_SLOTS_INCREMENT\": 250000\n}\n\nsmf \"unicorn\" do\n  user user\n\n  start_command \"bundle_exec unicorn_rails -c %{config/current_path}/config/unicorn/%{config/rails_env}.rb -E %{config/rails_env} -D\"\n  start_timeout 90\n  stop_command \":kill\"           ## this is redundant, as it is the default\n  stop_timeout 30\n  restart_command \":kill -SIGUSR2\"\n  restart_timout 120\n\n  environment(\n    {\"PATH\" => unicorn_path}.merge(garbage_collection_settings)\n  )\n\n  ## If you get into a case where the unicorn master is frequently reaping workers, SMF may notice \n  ## and put the service into maintenance mode. Instead, we tell SMF to ignore core dumps and \n  ## signals to children.\n  ignore [\"core\",\"signal\"]\n  property_groups({\n    \"config\" => {\n      \"rails_env\" => rails_env,\n      \"current_path\" => current_path\n    }\n  })\n  working_directory current_path\nend\n```\n\n### SideKiq\n\n```ruby\nclass Chef::Resource::Smf\n  include ::ProcessHelpers\nend\n\nrails_env     = node[:rails_env]\nuser          = node[:app][:user]\ndir           = \"/home/#{user}/#{node[:app][:dir]}\"\n\nsidekiq_yml   = \"#{dir}/config/sidekiq.yml\"\nsidekiq_pid   = \"#{dir}/tmp/pids/sidekiq.pid\"\nsidekiq_log   = \"#{dir}/log/sidekiq.log\"\n\nsmf \"sidekiq\" do\n  user user\n  start_command start_helper(\"(bundle exec sidekiq -e #{rails_env} -C #{sidekiq_yml} -P #{sidekiq_pid} >> #{sidekiq_log} 2>&1 &)\")\n  start_timeout 30\n  stop_command stop_helper(sidekiq_pid, :term)\n  stop_timeout 15\n  working_directory \"#{dir}\"\nend\n\nsidekiq_monitor_pid         = \"#{dir}/tmp/pids/sidekiq_monitor.pid\"\nsidekiq_monitor_run_path    = \"#{dir}/sidekiq_monitor.ru\"\nsidekiq_monitor_config_path = \"#{dir}/config/unicorn/sidekiq_monitor.rb\"\n\nsmf \"sidekiq-monitor\" do\n  user user\n  start_command start_helper(\"(BUNDLE_GEMFILE=#{dir}/Gemfile bundle exec unicorn -c #{sidekiq_monitor_config_path} -E #{rails_env} -D #{sidekiq_monitor_run_path} 2>&1)\")\n  start_timeout 30\n  stop_command stop_helper(sidekiq_monitor_pid, :term)\n  stop_timeout 15\n  working_directory \"#{dir}\"\nend\n```\n",
  "requires": [
    {
      "kind": "host",
      "label": "smartos",
      "revision": ">= 0.0.0",
      "one_of_group": "os"
    },
    {
      "kind": "env",
      "uri": "https://supermarket.chef.io/cookbooks/rbac",
      "revision": ">= 0.0.2",
      "self_resolve": true
    }
  ],
  "recommends": [
    {
      "kind": "env",
      "uri": "https://supermarket.chef.io/cookbooks/resource-control",
      "revision": ">= 0.0.0"
    }
  ]
}